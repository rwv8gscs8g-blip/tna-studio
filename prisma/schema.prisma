generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite" // DEV. Em prod: "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  MODEL
  CLIENT
}

model User {
  id                String   @id @default(cuid())
  name              String?
  email             String   @unique // em prod (Postgres): usar citext para case-insensitive
  passwordHash      String
  passwordUpdatedAt DateTime @default(now())
  role              Role     @default(MODEL)
  image             String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  accounts  Account[]
  sessions  Session[]
  galleries Gallery[]       @relation("OwnerGalleries")
  accesses  GalleryAccess[]
  links     SignedLink[]
  auditLogs AuditLog[]

  @@index([email])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Dono da galeria = userId
model Gallery {
  id          String   @id @default(cuid())
  title       String
  description String?
  coverImage  String? // pode ser uma key do R2
  userId      String
  isPrivate   Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user   User            @relation("OwnerGalleries", fields: [userId], references: [id], onDelete: Cascade)
  photos Photo[]
  access GalleryAccess[]
  links  SignedLink[]

  @@index([userId])
  @@index([createdAt])
}

// Foto aponta para uma key no R2 (não URL)
model Photo {
  id         String   @id @default(cuid())
  key        String // ex: "galeria/abc123/IMG_0001.jpg"
  mimeType   String?
  bytes      Int?
  checksum   String? // ex: sha256 para integridade (opcional)
  title      String?
  galleryId  String
  uploadedAt DateTime @default(now())

  gallery Gallery @relation(fields: [galleryId], references: [id], onDelete: Cascade)

  @@index([galleryId])
  @@index([uploadedAt])
}

// ACL por usuário (quem pode ver/baixar a galeria)
model GalleryAccess {
  id          String   @id @default(cuid())
  galleryId   String
  granteeId   String
  canDownload Boolean  @default(false)
  createdAt   DateTime @default(now())

  gallery Gallery @relation(fields: [galleryId], references: [id], onDelete: Cascade)
  grantee User    @relation(fields: [granteeId], references: [id], onDelete: Cascade)

  @@unique([galleryId, granteeId])
  @@index([granteeId])
}

// Link efêmero (token aleatório), não contém a URL real.
// O Worker valida token -> consulta tabela -> verifica expiração/uso -> assina a URL R2 e responde.
model SignedLink {
  id        String   @id @default(cuid())
  token     String   @unique // ex: base58/base64url rand (não previsível)
  galleryId String
  createdBy String // dono que gerou
  expiresAt DateTime
  maxUses   Int?
  usedCount Int      @default(0)
  createdAt DateTime @default(now())

  gallery Gallery @relation(fields: [galleryId], references: [id], onDelete: Cascade)
  owner   User    @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([galleryId])
  @@index([expiresAt])
}

// Log mínimo de auditoria de ações sensíveis
model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  action    String // ex: "LOGIN_SUCCESS", "LINK_CREATED", "DOWNLOAD"
  targetId  String?
  ip        String?
  userAgent String?
  createdAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([createdAt])
}
